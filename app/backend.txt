main.py:
from flask import Flask, send_from_directory
from .config import Config
from flask_migrate import Migrate
from .extensions import db, mail, login_manager, csrf
from flask_cors import CORS
from flask_wtf.csrf import CSRFProtect

import os

def create_app(config_class=Config):
    # Set static_folder to point to your React build output (e.g., "build")
    app = Flask(__name__, static_folder='build', static_url_path='')
    app.config.from_object(config_class)
    
    csrf.init_app(app)

    # Enable CORS for all routes. You can also restrict it if needed.
    CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}}, 
         supports_credentials=True,
         allow_headers=["Content-Type", "Authorization"],
         methods=["GET", "POST", "PUT", "DELETE"])
    
    # Initialize extensions
    db.init_app(app)
    mail.init_app(app)
    csrf.init_app(app)
    login_manager.init_app(app)
    login_manager.login_view = 'auth.login'
    Migrate(app, db)
    
    # Register user loader
    from .models import User
    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))
    
    # Register API blueprints
    from .routes import register_routes
    register_routes(app)
    
    # Catch-all route to serve the React app for any non-API route
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve_react(path):
        if path != "" and os.path.exists(os.path.join(app.static_folder, path)):
            return send_from_directory(app.static_folder, path)
        return send_from_directory(app.static_folder, 'index.html')
    
    return app

if __name__ == "__main__":
    app = create_app()
    app.run(debug=True)

config.py:
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY')

    # Email Configuration
    MAIL_SERVER = os.environ.get('MAIL_SERVER') or 'smtp.gmail.com'
    MAIL_PORT = int(os.environ.get('MAIL_PORT') or 587)
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'True').lower() in ['true', '1']
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    MAIL_DEFAULT_SENDER = os.environ.get('MAIL_DEFAULT_SENDER')

    # Session Configuration
    SESSION_COOKIE_SECURE = False  # For development
    SESSION_COOKIE_SAMESITE = 'Lax'  # Allow cross-origin cookies
    SESSION_COOKIE_NAME = "restaurant_session"
    SESSION_COOKIE_HTTPONLY = True
    SESSION_REFRESH_EACH_REQUEST = True

extensions.py:
from flask_sqlalchemy import SQLAlchemy
from flask_mail import Mail
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect

db = SQLAlchemy()
mail = Mail()
login_manager = LoginManager()
csrf = CSRFProtect()

models.py:
from app.extensions import db
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    is_admin = db.Column(db.Boolean, default=False)

    # For loyalty/CRM:
    loyalty_points = db.Column(db.Integer, default=0)
    # Or you can store membership tier, e.g. "Silver", "Gold", "Platinum"
    loyalty_tier = db.Column(db.String(50), default="Basic")

    def set_password(self, password):
        self.password = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password, password)

class UserPreference(db.Model):
    __tablename__ = 'user_preference'
    id = db.Column(db.Integer, primary_key=True)
    
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    user = db.relationship('User', backref='preferences')

    preferred_cuisine = db.Column(db.String(100), nullable=True)
    dietary_restrictions = db.Column(db.String(200), nullable=True)
    ambiance_preference = db.Column(db.String(100), nullable=True)
    
class Restaurant(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    location = db.Column(db.String(200), nullable=False)
    cuisine = db.Column(db.String(100), nullable=False)
    images = db.relationship('RestaurantImage', backref='restaurant', lazy=True, cascade="all, delete-orphan")

    capacity = db.Column(db.Integer, default=50)  
    booking_duration = db.Column(db.Integer, default=120)  # minutes
    average_price = db.Column(db.Float, nullable=True)

    lat = db.Column(db.Float)  # Latitude
    lon = db.Column(db.Float)  # Longitude
    features = db.Column(db.JSON)  # Store features as JSON array
    opening_time = db.Column(db.Time)
    closing_time = db.Column(db.Time)

    promo = db.Column(db.String(200), nullable=True)

    layouts = db.relationship('Layout', backref='restaurant', cascade="all, delete-orphan", lazy=True)

    @property
    def rating(self):
        if not self.reviews:
            return 4.0  # Default rating
        total = sum(review.rating for review in self.reviews)
        return round(total / len(self.reviews), 1)

class RestaurantImage(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    restaurant_id = db.Column(db.Integer, db.ForeignKey('restaurant.id'), nullable=False)
    image_url = db.Column(db.String(300), nullable=False)

class MenuItem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    restaurant_id = db.Column(db.Integer, db.ForeignKey('restaurant.id'))
    category = db.Column(db.String(50))
    name = db.Column(db.String(100))
    description = db.Column(db.String(300))
    price = db.Column(db.Float)

class Layout(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    restaurant_id = db.Column(db.Integer, db.ForeignKey('restaurant.id'), nullable=False)
    table_number = db.Column(db.Integer, nullable=False)
    x_coordinate = db.Column(db.Float, nullable=False)
    y_coordinate = db.Column(db.Float, nullable=False)
    shape = db.Column(db.String(50), default="rectangle")  # or 'circle', etc.
    capacity = db.Column(db.Integer, default=4)

class LayoutVersion(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    restaurant_id = db.Column(db.Integer, db.ForeignKey('restaurant.id'))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    layout_data = db.Column(db.JSON)  # Stores tables' positions
    description = db.Column(db.String(200))  # "Admin edit 2024-03-15" or "Auto-generated"
    is_suggestion = db.Column(db.Boolean, default=False)

class Booking(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    restaurant_id = db.Column(db.Integer, db.ForeignKey('restaurant.id'), nullable=False)
    
    # For clarifying how many seats are needed
    num_guests = db.Column(db.Integer, nullable=True, default=1)
    
    # Store the status, so you know if itâ€™s canceled, confirmed, completed, etc.
    status = db.Column(db.String(50), default='CONFIRMED')

    special_requests = db.Column(db.String(300), nullable=True)

    date = db.Column(db.DateTime, nullable=False)
    layout_id = db.Column(db.Integer, db.ForeignKey('layout.id'), nullable=False)

    # relationships
    restaurant = db.relationship('Restaurant', backref='bookings', lazy=True)

class Review(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    restaurant_id = db.Column(db.Integer, db.ForeignKey('restaurant.id'), nullable=False)
    rating = db.Column(db.Integer, nullable=False)
    comment = db.Column(db.String(500))
    date_created = db.Column(db.DateTime, default=datetime.utcnow)

routes\auth_routes.py:
# auth_routes.py
from flask import Blueprint, request, jsonify, session
from app.extensions import db, mail
from app.models import User, UserPreference, Review, Restaurant, Booking
from datetime import datetime, timedelta
import random
from flask_login import login_user, current_user, logout_user
from werkzeug.security import generate_password_hash, check_password_hash
from flask_mail import Message
from app.extensions import csrf
from app.utils.response import json_response
from app.utils.auth import api_login_required

auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

@auth_bp.route('/login', methods=['POST'])
@csrf.exempt 
def login():
    data = request.json
    email = data.get('email')
    password = data.get('password')
    user = User.query.filter_by(email=email).first()
    
    if user and check_password_hash(user.password, password):
        session.clear()  # Clear previous session
        session.permanent = True
        otp_code = str(random.randint(100000, 999999))
        session[f'otp_{user.id}'] = otp_code  # Store OTP in a named session key
        
        try:
            msg = Message('Your OTP Code', recipients=[user.email])
            msg.body = f"Verification code: {otp_code}"
            mail.send(msg)
            return json_response(data={
                "message": "OTP sent",
                "otp_required": True,
                "temp_user_id": user.id  # Include user ID for verification
            }, status=200)
        except Exception as e:
            return json_response(error=f"Failed to send OTP: {str(e)}", status=500)
    else:
        return json_response(error="Invalid credentials", status=401)

@auth_bp.route('/verify-otp', methods=['POST'])
@csrf.exempt
def verify_otp():
    data = request.json
    otp_code = data.get('otp_code')
    user_id = data.get('temp_user_id')  # Get from frontend
    
    if not user_id:
        return json_response(error="Session expired", status=401)
        
    user = User.query.get(user_id)
    if not user:
        return json_response(error="User not found", status=404)
    
    # Get OTP from session using user_id
    stored_code = session.get(f'otp_{user_id}')
    if not stored_code or otp_code != stored_code:
        return json_response(error="Invalid OTP", status=400)
    
    session.pop(f'otp_{user_id}', None)
    login_user(user)
    
    return json_response(data={
        "message": "Login successful",
        "user": {
            "id": user.id,
            "name": user.name,
            "email": user.email,
            "is_admin": user.is_admin
        }
    }, status=200)

@auth_bp.route('/register', methods=['POST'])
@csrf.exempt
def register():
    data = request.json
    name = data.get('name')
    email = data.get('email')
    password = data.get('password')
    if User.query.filter_by(email=email).first():
        return json_response(error="Email already registered.", status=400)
    new_user = User(name=name, email=email)
    new_user.password = generate_password_hash(password)
    db.session.add(new_user)
    db.session.commit()
    return json_response(data={"message": "Registration successful. Please log in."}, status=201)

@auth_bp.route('/profile', methods=['GET'])
@api_login_required
def profile():
    if current_user.preferences:
        pref = current_user.preferences[0]
        preferences_data = {
            "preferred_cuisine": pref.preferred_cuisine,
            "dietary_restrictions": pref.dietary_restrictions,
            "ambiance_preference": pref.ambiance_preference
        }
    else:
        preferences_data = {}
    return json_response(data={
        "id": current_user.id,
        "name": current_user.name,
        "email": current_user.email,
        "is_admin": current_user.is_admin,
        "loyalty_points": current_user.loyalty_points,
        "loyalty_tier": current_user.loyalty_tier,
        "preferences": preferences_data
    }, status=200)

@auth_bp.route('/profile/edit', methods=['POST'])
@api_login_required
@csrf.exempt
def edit_profile():
    data = request.json
    if not data:
        return json_response(error="Invalid data", status=400)

    # Ensure name and email are provided
    new_name = data.get("name")
    new_email = data.get("email")

    if not new_name or not new_email:
        return json_response(error="Name and email are required", status=400)

    # Check if the email is already taken (but allow the same email)
    existing_user = User.query.filter(User.email == new_email, User.id != current_user.id).first()
    if existing_user:
        return json_response(error="Email is already in use by another account.", status=400)

    # Update user info
    current_user.name = new_name
    current_user.email = new_email

    try:
        db.session.commit()
        return json_response(data={"message": "Profile updated successfully."}, status=200)
    except Exception as e:
        db.session.rollback()
        return json_response(error=f"Database error: {str(e)}", status=500)

@auth_bp.route('/preferences', methods=['POST'])
@api_login_required
@csrf.exempt
def update_preferences():
    data = request.json
    existing_pref = UserPreference.query.filter_by(user_id=current_user.id).first()
    if existing_pref:
        pref = existing_pref
    else:
        pref = UserPreference(user_id=current_user.id)
        db.session.add(pref)
    pref.preferred_cuisine = data.get('preferred_cuisine') or pref.preferred_cuisine
    pref.dietary_restrictions = data.get('dietary_restrictions') or pref.dietary_restrictions
    pref.ambiance_preference = data.get('ambiance_preference') or pref.ambiance_preference
    try:
        db.session.commit()
        return json_response(data={"message": "Preferences updated."}, status=200)
    except Exception as e:
        db.session.rollback()
        return json_response(error=f"Database error: {str(e)}", status=500)

@auth_bp.route('/logout', methods=['POST'])
@api_login_required
def logout():
    logout_user()
    return json_response(data={"message": "Logged out successfully."}, status=200)

routes\booking_routes.py:
# booking_routes.py
from flask import Blueprint, request, jsonify
from app.extensions import db, mail
from app.models import Booking, Restaurant, User, Layout
from datetime import datetime, timedelta
from flask_login import login_required, current_user
from flask_mail import Message
from sqlalchemy import func
from app.extensions import csrf
from app.utils.response import json_response

booking_bp = Blueprint('booking', __name__, url_prefix='/api/bookings')

def is_table_available(restaurant_id, layout_id, date):
    layout = Layout.query.get(layout_id)
    if not layout or layout.restaurant_id != restaurant_id:
        return False
    duration = Restaurant.query.get(restaurant_id).booking_duration
    start = date
    end = date + timedelta(minutes=duration)
    overlapping = Booking.query.filter(
        (Booking.layout_id == layout_id) &
        (Booking.restaurant_id == restaurant_id) &
        (Booking.date < end) &
        (Booking.date + timedelta(minutes=duration) > start)
    ).first()
    return not overlapping

@csrf.exempt
@booking_bp.route('', methods=['POST'])
def book_table():
    data = request.json
    user = User.query.get(data.get('user_id'))
    if not user:
        return json_response(error="User not found", status=404)
    restaurant = Restaurant.query.get(data.get('restaurant_id'))
    if not restaurant:
        return json_response(error="Restaurant not found", status=404)
    try:
        date_str = data.get('date')
        if 'T' in date_str:
            booking_date = datetime.strptime(date_str, "%Y-%m-%dT%H:%M")
        else:
            booking_date = datetime.strptime(date_str, "%Y-%m-%d")
    except (ValueError, TypeError):
        return json_response(error="Invalid date format. Use YYYY-MM-DD or YYYY-MM-DDTHH:MM", status=400)
    layout_id = data.get('layout_id')
    if not layout_id:
        return json_response(error="Invalid layout ID", status=400)
    if not is_table_available(restaurant.id, layout_id, booking_date):
        return json_response(error="Table not available at the requested time", status=409)
    num_guests = data.get('num_guests', 1)
    special_requests = data.get('special_requests')
    new_booking = Booking(
        user_id=data.get('user_id'),
        restaurant_id=data.get('restaurant_id'),
        date=booking_date,
        layout_id=layout_id,
        num_guests=num_guests,
        special_requests=special_requests,
    )
    db.session.add(new_booking)
    db.session.commit()
    msg = Message('Booking Confirmation', recipients=[user.email])
    msg.body = f"""
    Dear {user.name},
    Your booking at {restaurant.name} is confirmed!
    Date: {booking_date.strftime("%Y-%m-%d %H:%M")}
    Table Number: {layout_id}
    Number of Guests: {num_guests}
    """
    mail.send(msg)
    return json_response(data={"message": "Booking successful, email sent!"}, status=201)

@booking_bp.route('/<int:booking_id>', methods=['PUT'])
@login_required
@csrf.exempt
def update_booking(booking_id):
    booking = Booking.query.get_or_404(booking_id)
    if booking.user_id != current_user.id:
        return json_response(error="Unauthorized", status=403)
    data = request.json
    if 'date' in data:
        try:
            date_str = data.get('date')
            if 'T' in date_str:
                booking_date = datetime.strptime(date_str, "%Y-%m-%dT%H:%M")
            else:
                booking_date = datetime.strptime(date_str, "%Y-%m-%d")
            booking.date = booking_date
        except (ValueError, TypeError):
            return json_response(error="Invalid date format. Use YYYY-MM-DD or YYYY-MM-DDTHH:MM", status=400)
    if 'layout_id' in data:
        try:
            booking.layout_id = int(data.get('layout_id'))
        except (ValueError, TypeError):
            return json_response(error="Invalid layout ID", status=400)
    if 'num_guests' in data:
        booking.num_guests = data.get('num_guests')
    if 'special_requests' in data:
        booking.special_requests = data.get('special_requests')
    db.session.commit()
    return json_response(data={"message": "Booking updated successfully"}, status=200)

@booking_bp.route('/<int:booking_id>', methods=['DELETE'])
@login_required
@csrf.exempt
def cancel_booking(booking_id):
    booking = Booking.query.get_or_404(booking_id)
    if booking.user_id != current_user.id and not current_user.is_admin:
        return json_response(error="Unauthorized", status=403)
    db.session.delete(booking)
    db.session.commit()
    return json_response(data={"message": "Booking canceled successfully"}, status=200)

@booking_bp.route('/user', methods=['GET'])
@login_required
def get_user_bookings():
    bookings = Booking.query.filter_by(user_id=current_user.id).all()
    booking_list = [{
        "id": booking.id,
        "restaurant_id": booking.restaurant_id,
        "layout_id": booking.layout_id,  # Changed from table_number
        "date": booking.date.strftime("%Y-%m-%d %H:%M")
    } for booking in bookings]
    return json_response(data=booking_list, status=200)

@booking_bp.route('/analytics', methods=['GET'])
@login_required
def bookings_analytics():
    if not current_user.is_admin:
        return json_response(error="Admin privileges required", status=403)
    analytics = db.session.query(func.date(Booking.date), func.count(Booking.id)) \
                  .group_by(func.date(Booking.date)).all()
    result = [{"date": str(date), "bookings": count} for date, count in analytics]
    return json_response(data=result, status=200)

@booking_bp.route('/availability', methods=['GET'])
def get_available_tables():
    restaurant_id = request.args.get('restaurant_id')
    date_str = request.args.get('date')
    
    try:
        if 'T' in date_str:
            booking_date = datetime.strptime(date_str, "%Y-%m-%dT%H:%M")
        else:
            booking_date = datetime.strptime(date_str, "%Y-%m-%d")
    except (ValueError, TypeError):
        return json_response(error="Invalid date format. Use YYYY-MM-DD or YYYY-MM-DDTHH:MM", status=400)
    
    restaurant = Restaurant.query.get(restaurant_id)
    if not restaurant:
        return json_response(error="Restaurant not found", status=404)
    
    duration = restaurant.booking_duration
    start = booking_date
    end = booking_date + timedelta(minutes=duration)
    
    available_tables = Layout.query.filter(
        Layout.restaurant_id == restaurant_id,
        ~db.session.query(Booking.id).filter(
            (Booking.layout_id == Layout.id) &
            (Booking.restaurant_id == restaurant_id) &
            (Booking.date < end) &
            (Booking.date + timedelta(minutes=duration) > start)
        ).exists()
    ).all()
    
    layout_ids = [table.id for table in available_tables]
    
    return json_response(data={"available_tables": layout_ids}, status=200)

@booking_bp.route('/count/this-week', methods=['GET'])
def get_bookings_this_week():
    today = datetime.utcnow()
    start_of_week = today - timedelta(days=today.weekday())  # Monday of this week
    end_of_week = start_of_week + timedelta(days=7)  # End of week
    count = Booking.query.filter(
        Booking.date >= start_of_week,
        Booking.date < end_of_week
    ).count()
    return json_response(data={"count": count}, status=200)

routes\restaurant_routes.py:
# restaurant_routes.py
from flask import Blueprint, request, jsonify
from app.extensions import db, mail
from app.models import Restaurant, MenuItem, RestaurantImage, Layout, Review, LayoutVersion
from flask_login import login_required, current_user
from flask_mail import Message
import random
import math
from app.extensions import csrf
from app.utils.response import json_response

restaurant_bp = Blueprint('restaurant', __name__, url_prefix='/api/restaurants')

@restaurant_bp.route('', methods=['GET'])
def get_restaurants():
    restaurants = Restaurant.query.all()
    restaurants_list = [{
        "id": r.id,
        "name": r.name,
        "location": r.location,
        "cuisine": r.cuisine,
        "promo": r.promo,
        "lat": r.lat,
        "lon": r.lon,
        "opening_time": r.opening_time.strftime("%H:%M") if r.opening_time else None,
        "closing_time": r.closing_time.strftime("%H:%M") if r.closing_time else None,
        "image_url": r.images[0].image_url if r.images else "/static/placeholder.png"
    } for r in restaurants]
    return json_response(data=restaurants_list, status=200)

@restaurant_bp.route('', methods=['POST'])
@login_required
@csrf.exempt
def add_restaurant():
    if not current_user.is_admin:
        return json_response(error="Admin privileges required", status=403)

    data = request.json
    name = data.get('name')
    location = data.get('location')
    cuisine = data.get('cuisine')

    # Basic validation
    if not name or len(name.strip()) < 2:
        return json_response(error="Restaurant name must be at least 2 characters", status=400)
    if not location or not cuisine:
        return json_response(error="Location and cuisine are required", status=400)

    try:
        db.session.begin_nested()  # Start transaction
        new_restaurant = Restaurant(
            name=name,
            location=location,
            cuisine=cuisine,
            promo=data.get('promo'),  # Add promo field
            lat=data.get('lat'),
            lon=data.get('lon'),
            opening_time=data.get('opening_time'),
            closing_time=data.get('closing_time')
        )
        db.session.add(new_restaurant)
        db.session.flush()  # Assign ID before adding images

        image_urls = data.get('image_urls', [])
        for url in image_urls:
            url = url.strip()
            if url:
                restaurant_image = RestaurantImage(restaurant_id=new_restaurant.id, image_url=url)
                db.session.add(restaurant_image)

        db.session.commit()
    except Exception as e:
        db.session.rollback()
        return json_response(error="Failed to create restaurant", status=500)

    return json_response(data={"message": "Restaurant added successfully", "restaurant_id": new_restaurant.id}, status=201)

@restaurant_bp.route('/<int:restaurant_id>', methods=['GET'])
def restaurant_details(restaurant_id):
    restaurant = Restaurant.query.get_or_404(restaurant_id)
    data = {
        "id": restaurant.id,
        "name": restaurant.name,
        "location": restaurant.location,
        "cuisine": restaurant.cuisine,
        "promo": restaurant.promo,
        "lat": restaurant.lat,
        "lon": restaurant.lon,
        "opening_time": restaurant.opening_time.strftime("%H:%M") if restaurant.opening_time else None,
        "closing_time": restaurant.closing_time.strftime("%H:%M") if restaurant.closing_time else None,
        "images": [img.image_url for img in restaurant.images],
        "capacity": restaurant.capacity,
        "average_price": restaurant.average_price,
        "features": restaurant.features
    }
    return json_response(data=data, status=200)

@restaurant_bp.route('/<int:restaurant_id>', methods=['PUT'])
@login_required
@csrf.exempt
def edit_restaurant(restaurant_id):
    if not current_user.is_admin:
        return json_response(error="Admin privileges required", status=403)
    restaurant = Restaurant.query.get_or_404(restaurant_id)
    data = request.json
    restaurant.name = data.get('name', restaurant.name)
    restaurant.location = data.get('location', restaurant.location)
    restaurant.cuisine = data.get('cuisine', restaurant.cuisine)
    restaurant.promo = data.get('promo', restaurant.promo)
    restaurant.lat = data.get('lat', restaurant.lat)
    restaurant.lon = data.get('lon', restaurant.lon)
    restaurant.opening_time = data.get('opening_time', restaurant.opening_time)
    restaurant.closing_time = data.get('closing_time', restaurant.closing_time)

    # Remove existing images and add new ones
    RestaurantImage.query.filter_by(restaurant_id=restaurant.id).delete()
    image_urls = data.get('image_urls', [])
    for url in image_urls:
        url = url.strip()
        if url:
            new_image = RestaurantImage(restaurant_id=restaurant.id, image_url=url)
            db.session.add(new_image)

    db.session.commit()
    return json_response(data={"message": "Restaurant updated successfully"}, status=200)

@restaurant_bp.route('/<int:restaurant_id>', methods=['DELETE'])
@login_required
@csrf.exempt
def delete_restaurant(restaurant_id):
    if not current_user.is_admin:
        return json_response(error="Admin privileges required", status=403)
    restaurant = Restaurant.query.get_or_404(restaurant_id)
    # Delete related layouts first
    Layout.query.filter_by(restaurant_id=restaurant.id).delete()
    db.session.delete(restaurant)
    db.session.commit()
    return json_response(data={"message": "Restaurant deleted successfully"}, status=200)

@restaurant_bp.route('/search', methods=['GET'])
def search_restaurants():
    search_query = request.args.get('q', '')
    cuisine_filter = request.args.get('cuisine', '')
    min_rating = request.args.get('min_rating', 0, type=float)

    query = Restaurant.query

    if search_query:
        query = query.filter(
            (Restaurant.name.ilike(f'%{search_query}%')) | 
            (Restaurant.location.ilike(f'%{search_query}%'))
        )

    if cuisine_filter:
        query = query.filter_by(cuisine=cuisine_filter)

    if min_rating > 0:
        query = query.filter(Restaurant.rating >= min_rating)

    results = query.all()

    return json_response(data=[{
        "id": r.id,
        "name": r.name,
        "cuisine": r.cuisine,
        "rating": r.rating,  # Now using the computed property
        "lat": r.lat,
        "lon": r.lon,
        "features": r.features,
        "promo": r.promo,
        "image_url": r.images[0].image_url if r.images else ''
    } for r in results], status=200)

@restaurant_bp.route('/<int:restaurant_id>/menu', methods=['GET'])
def get_menu(restaurant_id):
    menu_items = MenuItem.query.filter_by(restaurant_id=restaurant_id).all()
    return json_response(data=[{
        "category": item.category,
        "name": item.name,
        "description": item.description,
        "price": item.price
    } for item in menu_items], status=200)

@restaurant_bp.route('/recommendations', methods=['GET'])
@login_required
def restaurant_recommendations():
    """
    A simple content-based recommender:
    1) Look at current_user's preferences.
    2) For each restaurant, compute a 'score' based on matching preferences.
    3) Sort by score desc, return top 5.
    """
    user_pref = current_user.preferences[0] if current_user.preferences else None
    restaurants = Restaurant.query.all()

    if not user_pref:
        # If user has no preferences, just return all or random.
        # Return them unfiltered for simplicity
        return json_response(data=[
            {
                "id": r.id,
                "name": r.name,
                "location": r.location,
                "cuisine": r.cuisine
            } for r in restaurants
        ], status=200)

    # Extract user prefs
    pref_cuisine = user_pref.preferred_cuisine.lower() if user_pref.preferred_cuisine else None
    dietary_res = user_pref.dietary_restrictions.lower() if user_pref.dietary_restrictions else ""
    ambiance_pref = user_pref.ambiance_preference.lower() if user_pref.ambiance_preference else ""

    # We'll store (score, restaurant_obj) in a list
    scored_restaurants = []

    for r in restaurants:
        score = 0

        # 1) Cuisine match => +2
        if pref_cuisine and pref_cuisine in r.cuisine.lower():
            score += 2

        # 2) If "no peanuts" and r might be "peanut-heavy" => skip or reduce
        # For example, if user said "no peanuts" in dietaryRes,
        # But your restaurant data doesn't store it, you can skip or
        # do partial matching. We'll just do a naive example:
        if "no peanuts" in dietary_res:
            # If the restaurant has 'peanut' in its name/cuisine => reduce points
            if "peanut" in r.cuisine.lower():
                # or skip entirely
                score -= 999  # effectively kill it
        # If the user said "vegan" but r has "steak" in cuisine => also kill it, etc.

        # 3) Ambiance => if you had a field r.ambiance
        # We'll do a naive example
        # if r.ambiance and ambiance_pref in r.ambiance.lower():
        #     score += 1

        # If the restaurant hasn't been effectively killed, keep it
        scored_restaurants.append((score, r))

    # Sort by score descending
    scored_restaurants.sort(key=lambda x: x[0], reverse=True)

    # Return top 5 or top 10
    top_5 = scored_restaurants[:5]

    # Convert to JSON
    result = []
    for (scr, rest) in top_5:
        if scr < 0:
            continue  # skip if negative
        result.append({
            "id": rest.id,
            "name": rest.name,
            "location": rest.location,
            "cuisine": rest.cuisine,
            # "score": scr, # optionally return the score
        })

    return json_response(data=result, status=200)

@restaurant_bp.route('/<int:restaurant_id>/layout', methods=['GET'])
def get_restaurant_layout(restaurant_id):
    # Define safe region for tables (in percentages)
    safe_x_min = 20
    safe_x_max = 80
    safe_y_min = 20
    safe_y_max = 80

    # Try to load existing tables from DB
    tables = Layout.query.filter_by(restaurant_id=restaurant_id).all()

    # If no tables exist, generate a baseline layout
    if not tables:
        # Randomly choose between a ring layout and a grid layout
        if random.random() < 0.5:
            # Ring layout within safe zone: center at (50,50) and radius that keeps tables in [20,80]
            total_tables = 8
            max_radius = min(50 - safe_x_min, safe_x_max - 50)  # = 30
            radius_px = random.randint(10, int(max_radius))  # choose a radius between 10 and 30
            for i in range(total_tables):
                angle = 2 * math.pi * i / total_tables
                # Compute percentage positions
                x_percent = 50 + radius_px * math.cos(angle)
                y_percent = 50 + radius_px * math.sin(angle)
                # Ensure values are clamped into safe zone
                x_percent = max(safe_x_min, min(safe_x_max, x_percent))
                y_percent = max(safe_y_min, min(safe_y_max, y_percent))
                new_table = Layout(
                    restaurant_id=restaurant_id,
                    table_number=i + 1,
                    x_coordinate=x_percent,
                    y_coordinate=y_percent,
                    shape='circle',
                    capacity=4
                )
                db.session.add(new_table)
        else:
            # Grid layout within safe zone
            rows = 3
            cols = 3
            # Compute spacing so that the grid fits within safe region.
            # safe region width in % = (safe_x_max - safe_x_min)
            horizontal_spacing = (safe_x_max - safe_x_min) / (cols - 1) if cols > 1 else 0
            vertical_spacing = (safe_y_max - safe_y_min) / (rows - 1) if rows > 1 else 0

            table_number = 1
            for row in range(rows):
                for col in range(cols):
                    x_percent = safe_x_min + col * horizontal_spacing
                    y_percent = safe_y_min + row * vertical_spacing
                    new_table = Layout(
                        restaurant_id=restaurant_id,
                        table_number=table_number,
                        x_coordinate=x_percent,
                        y_coordinate=y_percent,
                        shape='rectangle',
                        capacity=4
                    )
                    db.session.add(new_table)
                    table_number += 1
        db.session.commit()
        tables = Layout.query.filter_by(restaurant_id=restaurant_id).all()

    # Build layout items for response
    layout_data = [{
        "id": t.id,
        "table_number": t.table_number,
        "x_coordinate": t.x_coordinate,
        "y_coordinate": t.y_coordinate,
        "shape": t.shape,
        "capacity": t.capacity,
        "type": "table"
    } for t in tables]

    # Always add ephemeral furniture in fixed positions outside the safe zone:
    furniture = [
        {
            "id": 101,
            "name": "Bar",
            "x_coordinate": 5,   # top-left corner (outside safe zone)
            "y_coordinate": 5,
            "width": 10,
            "height": 8,
            "color": "#6c757d",
            "type": "furniture"
        },
        {
            "id": 102,
            "name": "Stage",
            "x_coordinate": 90,  # bottom-right corner (outside safe zone)
            "y_coordinate": 90,
            "width": 10,
            "height": 10,
            "color": "#343a40",
            "type": "furniture"
        }
    ]

    return json_response(data=layout_data + furniture, status=200)

@restaurant_bp.route('/<int:restaurant_id>/layout', methods=['PUT'])
@login_required
@csrf.exempt
def update_layout(restaurant_id):
    if not current_user.is_admin:
        return json_response(error="Admin privileges required", status=403)

    data = request.json
    new_layout = data.get('layout')
    if not new_layout:
        return json_response(error="No layout data provided", status=400)

    # Validate coordinates for each table
    for table_data in new_layout:
        x = table_data.get('x_coordinate')
        y = table_data.get('y_coordinate')
        if not (20 <= x <= 80) or not (20 <= y <= 80):
            return json_response(
                error=f"Table {table_data.get('id')}: Coordinates must be between 20% and 80%",
                status=400
            )

    # Update existing tables
    for table_data in new_layout:
        table = Layout.query.get(table_data.get('id'))
        if table and table.restaurant_id == restaurant_id:
            table.x_coordinate = float(table_data.get('x_coordinate', table.x_coordinate))
            table.y_coordinate = float(table_data.get('y_coordinate', table.y_coordinate))
            table.capacity = int(table_data.get('capacity', table.capacity))

    new_version = LayoutVersion(
        restaurant_id=restaurant_id,
        layout_data=new_layout
    )
    db.session.add(new_version)
    db.session.commit()

    return json_response(data={"message": "Layout updated successfully"}, status=200)

@restaurant_bp.route('/<int:restaurant_id>/suggest-layout', methods=['POST'])
@login_required
@csrf.exempt
def suggest_layout(restaurant_id):
    if not current_user.is_admin:
        return json_response(error="Admin privileges required", status=403)
    
    # Remove existing layout for a fresh start
    Layout.query.filter_by(restaurant_id=restaurant_id).delete()
    db.session.commit()

    total_tables = random.randint(8, 12)
    container_width = 800
    container_height = 600
    center_x = container_width / 2
    center_y = container_height / 2
    max_radius = min(50 - 20, 80 - 50)  # using safe zone 20-80%
    radius = random.randint(10, 30)
    offset_angle = random.random() * math.pi

    MIN_DISTANCE = 5.0  # Minimum distance between tables (in percentage)

    generated_tables = []
    for i in range(total_tables):
        collision = True
        attempts = 0
        while collision and attempts < 100:
            # Generate candidate position
            angle = 2 * math.pi * i / total_tables + offset_angle
            x_px = center_x + radius * math.cos(angle)
            y_px = center_y + radius * math.sin(angle)
            x_percent = (x_px / container_width) * 100
            y_percent = (y_px / container_height) * 100
            x_percent = max(20, min(80, x_percent))
            y_percent = max(20, min(80, y_percent))

            # Check for collisions
            collision = False
            for existing in generated_tables:
                dx = existing['x'] - x_percent
                dy = existing['y'] - y_percent
                distance = math.sqrt(dx**2 + dy**2)
                if distance < MIN_DISTANCE:
                    collision = True
                    radius += 1  # Adjust radius to avoid collision
                    break

            attempts += 1

        if not collision:
            generated_tables.append({'x': x_percent, 'y': y_percent})
            # Create and save new table
            new_table = Layout(
                restaurant_id=restaurant_id,
                table_number=i + 1,
                x_coordinate=x_percent,
                y_coordinate=y_percent,
                shape='circle' if random.random() < 0.5 else 'rectangle',
                capacity=random.randint(2, 8)
            )
            db.session.add(new_table)
    db.session.commit()

    tables = Layout.query.filter_by(restaurant_id=restaurant_id).all()
    layout_data = [{
        "id": t.id,
        "table_number": t.table_number,
        "x_coordinate": t.x_coordinate,
        "y_coordinate": t.y_coordinate,
        "shape": t.shape,
        "capacity": t.capacity,
        "type": "table"
    } for t in tables]

    # Ephemeral furniture always appended in fixed safe spots
    furniture = [
        {
            "id": 101,
            "name": "Bar",
            "x_coordinate": 5,
            "y_coordinate": 5,
            "width": 10,
            "height": 8,
            "color": "#6c757d",
            "type": "furniture"
        },
        {
            "id": 102,
            "name": "Stage",
            "x_coordinate": 90,
            "y_coordinate": 90,
            "width": 10,
            "height": 10,
            "color": "#343a40",
            "type": "furniture"
        }
    ]
    return json_response(data=layout_data + furniture, status=200)

@restaurant_bp.route('/<int:restaurant_id>/reviews', methods=['GET'])
def list_reviews(restaurant_id):
    page = request.args.get('page', 1, type=int)
    per_page = 10

    reviews = Review.query.filter_by(restaurant_id=restaurant_id).order_by(Review.date_created.desc()).paginate(page=page, per_page=per_page)

    reviews_list = [{
        "id": r.id,
        "user_id": r.user_id,
        "restaurant_id": r.restaurant_id,
        "rating": r.rating,
        "comment": r.comment,
        "date_created": r.date_created
    } for r in reviews.items]

    return json_response(data={
        "reviews": reviews_list,
        "total_pages": reviews.pages
    }, status=200)

@csrf.exempt
@restaurant_bp.route('/<int:restaurant_id>/reviews', methods=['POST'])
@login_required
def add_review(restaurant_id):
    data = request.json
    rating = data.get('rating')
    comment = data.get('comment')

    if not rating or not comment:
        return json_response(error="Rating and comment are required", status=400)

    if not (1 <= rating <= 5):
        return json_response(error="Rating must be 1-5", status=400)
    
    new_review = Review(
        user_id=current_user.id,
        restaurant_id=restaurant_id,
        rating=rating,
        comment=comment
    )
    db.session.add(new_review)
    db.session.commit()

    return json_response(data={"message": "Review added successfully", "review_id": new_review.id}, status=201)

@restaurant_bp.route('/count', methods=['GET'])
def get_restaurant_count():
    count = Restaurant.query.count()
    return json_response(data={"count": count}, status=200)

utils\auth.py:
from flask import jsonify
from flask_login import current_user

def api_login_required(func):
    def wrapper(*args, **kwargs):
        if not current_user.is_authenticated:
            return jsonify({"error": "Unauthorized"}), 401
        return func(*args, **kwargs)
    wrapper.__name__ = func.__name__  # Preserve the function name for Flask
    return wrapper

utils/response.py:
from flask import jsonify

def json_response(data=None, error=None, status=200):
    return jsonify({"data": data, "error": error}), status

